{remremoval:off}
{alpha:invert}
{crunch:on}

' use label assignments generated by t.main:
{uses:.\includes\label-assignments.lbl}

'  if {include}d into t.main, avoid line # conflict (already starts at line 1):
{ifdef:include_filler}
	{nice:10}
{else}
' otherwise, standalone program starts at line 1 if compiled by itself:
	{number:1}
{endif}

	rem T.NP
	{def:debug}
	{uses:.\includes\build-date_basic.lbl}

' updates:
' 2014/03/30: GOTOs cannot be used in place of GOSUB:RETURN (modBASIC rule)

' 2014/02/17  22:37 - resolved illegal quantity when finalizing character stats

' 2013/12/13	v0.9	integrated "message chunk" read routine from "fix index"

' 2012:  3/23  8/11  8/18
' 2011:  3/3   5/25  9/13
' 2003: 11/27

	goto {:np_setup}

{remremoval:on}

' FIXME: where did entering descs go?
' FIXME: need to read message # 5 - new player description

{nice:10}
{:sub.show_date} ' (date,month,0: current year, 1: birth year)
	fn d,m,y ' function prototype

' shows month, date and year

' expects:	d	date
'		m	month
'		y=0	print current year
' 		y=1	print birth year

' local:	x	year
	def x
' (107 chars)
	gosub {:sub.string_truncate}(mid$("January  February March    April    May      June     July     August   SeptemberOctober  November December",m*9-8,9))

' if y=. then print "20"mid$(d1$,6,2);:return
' x=2000+val(mid$(d1$,6,2))-peek(v1+144):print mid$(str$(x),2);:return

' print month, date:
	print x$;d",";
' print either current year (y=0) or birth year (y=1, subtract age):
	x=2000+val(mid$(d1$,6,2)):if y then x=x-peek(v1+144)
	print x;:return

{nice:10}
{:sub.set_date} ' (date,month,0: current year, 1: birth year)
	fn d,m,y ' function prototype
	def x
' sets date, month, and year

' expects:	d	date
'		m	month
'		y=0	set current year
' 		y=1	set birth year
' peek(v1+144) is age:
	x=val(mid$(d1$,6,2):if y then x=x-peek(v1+144)
	poke v1+98,d:poke v1+99,m:poke v1+100,20:poke v1+101,x:return

'{nice:10}
'	a$="e.t.messages":return

{nice:10}
{:sub.percentage} ' (number,percentage_of,width 1-3,columns)
' this subroutine is in t.main already {:msg.percentage}, except for the tabs
	x%=x/m*100:print right$("  "+str$(x),3)tab(17)
	print str$(m)tab(21)right$("  "+str$(x%),3)"%":return

' increase record length to 236 to avoid "overflow in record" error?

{nice:100}
{:np_setup}
' --- setup ---
	print "{off}Finding your place in the universe...";

' 28/Dec/2014 13:14
' redefine a$ and i% since start of strings (or something) got moved between
' initializing t.main and loading t.startup (causes sub.block_read to fail)
	na$="---"
    {uses:.\includes\player-setup.lbl}
' now defined: na$, d$, d2$

' na$ would be gotten from commodoreserver handle:
	h1$=left$(na$,18)
	gosub {:file.open_playerlog}:if e then {:error}
	gosub {:record_pointer}(1):input# 2,mx:x=. ' mx=max # of players
{:913}
	print ".";:x=x+2:if x/2>mx then {:920}
' don't set "crflag" for input any
	gosub {:record_pointer}(x):sys ia,2,20,0,a$
{ifdef:debug}
	print q$a$q$
{endif}
' get rid of spaces on right end of string:
' sub.string_truncate returns x$
' if x$<>"---" then this spot is taken
	gosub {:sub.string_truncate}(mid$(a$,3,18)):if x$<>"---" then {:913}
	pn=x:goto {:935}
{:920}
' create new player
	print "{on}":print "Creating one."
' fixme: only do this if there are no empty records:
' update highest player #:
	mx=mx+1:gosub {:record_pointer}(1):print# 2,mx
' write blank player record to disk:
	x=mx*2+1:pn=x:gosub {:record_pointer}(pn):print# 2,d$
	gosub {:record_pointer}(pn+1):print# 2,d2$
{:935}
' find addresses of strings [now using double-byte peek function dp(x)]:
' 2/Jan/2015 12:41 must use old method until modbasic can use normal fn() calls
{ifdef:fn_fix}
	sys 45195d$::v1=fn dp(780)+1:v1=fn dp(v1)-1
	sys 45195d2$:v2=fn dp(780)+1:v2=fn dp(v2)-1
{else}
	sys 45195d$::v1=peek(780)+b1*peek(781)+1:v1=peek(v1)+b1*peek(v1+1)-1
	sys 45195d2$:v2=peek(780)+b1*peek(781)+1:v2=peek(v2)+b1*peek(v2+1)-1
{endif}

' see file-formats.txt for how this date is constructed & read:
	d1$="71208188142"

' set last play date (month & day):
	poke v1+22,val(mid$(d1$,2,2)):poke v1+23,val(mid$(d1$,4,2))

' set birthday year:
	poke v1+100,20:poke v1+101,val(mid$(d1$,6,2))

' define computer type (1=Commodore), whether keyboard has Return or Enter key:
'	k$="Return":if co%>2 then k$="Enter"
	co%=1:k$=mid$("ReturnEnter",6*-(co%>2)+1,6)+""

'	NEW: un-needed since word-wrap added
'	calculate screen width, could also use kernal routine
'	printr$"{left}";:ll%=pos(.)+1:l$=mid$(r$+" ",ll%/40,1)

{ifdef:bbs}
	tr%=1 ' time remaining for call
{endif}

' turn more prompt/room descs on:
	gosub {:bit.set}(v1+64,3):gosub {:bit.set}(v1+64,2)

' to get time from cmd hd, use subroutine at {:sub.show_date}
' done: subroutine 'yes/no' getkey/response {:sub.yes_no}

{nice:50}
' #1 - new player intro:

{ifdef:trace}
' enable trace:
	sys 828+6:print "Trace enabled."
{endif}

	gosub {:msg.fancy_line}
	gosub {:sub.block_read}(1)

'	for i=1 to 5:on i gosub {:sub.gender},{:31},{:41},{:sub.choose_race},{:85}:next:print:goto {:136}
' 11/Jan/2015 13:33 - loop and on-gosub eliminated to be more compatible with
' modbasic

	gosub {:sub.gender}:gosub {:31}:gosub {:41}:gosub {:sub.choose_race}:gosub {:85}:print:goto {:136}
{:sub.gender}
	print "I. Gender"
	print "Verus squints myopically, "q$"Are you male or female?"q$
	print "Your response [M/F]: ";
{:28}
' "chr$(asc(an$) and 127)" converts an$ to lowercase
	gosub {:sub.cursor_get}:sys is,"mf",chr$(asc(an$) and 127):if i%=. then {:28}
	if i%=1 then:gosub {:bit.set}(v1+64,1):print "M";:goto {:gender2}
	gosub {:bit.clear}(v1+64,1):print "Fem";
{:gender2}
	print "ale.":return

{:31}
	print "II. Name"
{:32}
' fills 3 lines:
	print "{off}"q$"Choose a name for your character. Enterit now, and it must be no longer than 18characters."q$
	print:print tab(13)"[------------------]":i$=""
{:34}
	if a$(0)<>"" then print "Is currently: "a$(0)
	print "Your name is: ";:sys si,18,19,i$:if i$<>"" or a$(.)<>"" then {:38}
	gosub {:check.gender}:print q$"Come off it, ";:if s=. then print "wo";
	sys br,"man! Enter [something]!"+q$+r$+nl$:goto {:32}
{:38}
	gosub {:sub.i_string_uppercase}
' na$ would be commodoreserver username, part of the fun is having differently
' named characters so you're not sure of whom is whom
	if i$=left$(na$,18) then print "Verus tsks, "q$"Please don't use your CommodoreServer handle."q$:goto {:34}
' fixme: IF i$="" AND A$(.)<>"" THEN AN$=A$(.) ---> ???

{:650}
	gosub {:file.open_playerlog}:if e then {:1811}
	print "{on}Verus checks whether anyone has already heard of "i$"...{off}";:t=x:x=.
{:652}
	x=x+2:if x/2>mx then {:657}
	gosub {:record_pointer}(x)
	sys ia,2,20,0,a$:print ".";:if left$(mid$(a$,3,18)+"{space:18}",18)<>right$(i$,18) then {:652}
{:656}
' todo: ? could get list of player names, should create subroutine in t.main for that
	print:print "{on}"q$"Sorry, there's already someone by that name. Please choose another!"q$"{off}":er=1:goto {:32}
{:657}
' put player name in player data:
	for x=1 to len(a$(.)):poke v1+10+x,asc(mid$(a$(.),x,1)+nl$):next

' check gender:
	gosub {:check.gender}:print:print "{on}"q$;:if s=. then print "Sh";:goto {:msg.first}
	print "H";
{:msg.first}
	print "e's the first one around here!"q$"{off}":er=.
{:658}
' fixme: is t unnecessary now?
	x=t:if er then {:32}
	a$(.)=i$:return

{:41}
	print "III. Class and Race":print
' todo: add explanation of class and race!
	print "{on}"q$"Now you may choose a class and race for "a$(0)". Do you want these terms explained, and to see a list of acceptable class and race combinations first?"q$
	print "Your response{off}";
{:47}
' new {:sub.yes_no} routine (1="yes" default):
	gosub {:sub.yes_no}(1):print "{on}";:if a=. then {:54}
	print q$"Very well."q$" Verus sighs, takes a worn scroll out from somewhere under his cloak, and begins reading in a bored tone of voice:{off}":print
' todo: read file (unknown filename)
	print "[Disk file read...]":goto {:prevent_change}
{:54}
	print q$"I understand,"q$" smiles Verus. "q$"You're impatient to get on with more important things, I see..."q$
	print "He chuckles softly to himself, then continues."

{:prevent_change}
' prevent class/race change (don't check for valid class/race combo):
	c=0

{:choose_class_race_lp}
' subroutines needed here for changing class/race in final edit menu:
	gosub {:sub.choose_class}:gosub {:sub.choose_race}:on er goto {:prevent_change}:goto {:85}

{:sub.choose_class}
	print"{off}":print q$"Choose a class,"q$" Verus instructs.":print
	print "(1) Wizard   (4) Paladin  (7) Archer"
	print "(2) Druid    (5) Ranger   (8) Assassin"
	print "(3) Fighter  (6) Thief    (9) Knight"
	print:print "Class number [1-9] >> ";
' todo: add [?] option
{:62}
	gosub {:sub.cursor_get}:gosub {:string.normalize}(an$):on -(an<1 or an>9) goto {:62}:print mid$(cl$,an*8-7,8)
' first pass, c=0 so don't check:
	if c then gosub {:sub.check_class_race}:if er then {:sub.choose_class}
' store class (1-9) when correct:
	poke v1+68,x:return

{:sub.choose_race}
' c=1: class change possible only after selecting a valid race
	print:print q$"Choose a race,"q$" Verus instructs.":print:AN$=""
	print "(1) Human    (4) Elf      (7) Dwarf"
	print "(2) Ogre     (5) Hobbit   (8) Orc"
	print "(3) Gnome    (6) Halfling (9) Half-Elf":print
	if c then print "[C]hange class":print
	print "Race number [1-9";:if c then print", C";
	print "] >> ";
' todo: add [?] option
{:71}
	gosub {:sub.cursor_get}:if an$="c" and c=1 then {:84}
	gosub {:string.normalize}(an$):if an<1 or an>9 then {:71}
{:72}
	print mid$(rc$,an*8-7,8):gosub {:sub.check_class_race}:if er then {:sub.choose_race}
' store race (1-9) when correct:
' c=1: class change possible only after selecting a valid class and race
	poke v2+185,an:c=1:return
{:84}
' setting c=1 here should go back to 'choose class'
	print "Change class.":c=1:gosub {:sub.choose_class}

{:sub.check_class_race}
' bad combinations:
	z=peek(v1+68)+1:y=peek(v2+185)+1	' z=class	y=race
	if z=1 and y=2 or y=7 or y=8 then {:82}	' wizard	ogre	dwarf	orc
	if z=2 and y=2 or y=8 then {:82}	' druid		ogre	orc
	if z=6 and y=4 then {:82}		' thief		elf
	if z=7 and y=2 or y=3 or y=5 then {:82}	' archer	ogre	gnome	hobbit
	if z=8 and y=3 or y=4 or y=5 then {:82}	' assassin	gnome	elf	hobbit
	if z=9 and y=2 or y=8 then {:82}	' knight	ogre	orc
	print r$q$"Okay, fine with me,"q$" agrees Verus.":er=.:return
{:82}
	gosub {:sub.string_truncate}(mid$(cl$,y*8-7,8)):z$=x$+" ":gosub {:sub.string_truncate}(mid$(rc$,z*8-7,8)):z$=z$+x$
' check for AEIOU in left$(x$,1):
	print:sys is,"AEIOU",left$(x$,1):print "{on}"q$"A";:if i% then print "n";
	print " "z$" doth not a good adventurer make! Try again!"q$"{off}":er=1:return

{:85}
	print:print "IV. Age"
{:86}
	print:gosub {:sub.block_read}(2):an$="0"
{:99}
' test to see if clearing quote mode helps not print rvs on/off chars:
' poke 212,0 does not fix it (clear quote mode)
	print:sys br,"Age (15-50, [0]/R): "+nl$:sys si,3,4,an$:print "{on}";
':if an$="0" then {:101}
	gosub {:string.normalize}(an$)
'  The general formula for generating a set of random numbers in a certain
'range is:
'
'  NUMBER=INT(LOWER+(UPPER-LOWER+1)*RND(1))

	if an$="r" or an$="R" then an=fn r(35)+14
{:101}
' if undetermined, year=0:
	if an=. then print "You're of an unknown age.":poke v1+144,.:goto {:108}
	if an<15 then print q$"Oh, come off it! You're not even old enough to handle a Staff yet! Get real!"q$:goto {:99}
{:104}
	if an>50 then print q$"Hmmm, we seem to be out of Senior Adventurer life insurance policies right now. Come back tomorrow!"q$:goto {:99}
{:107}
' str$(an) used here to eliminate printing crsr right in quote mode
	print q$"You're"str$(an)" years old."q$:poke v1+144,an
{:108}
	print:print "{off}Would you like your birthday to be:"
' todo: get server date
	dx=val(mid$(d1$,2,2)):mx=val(mid$(d1$,4,2))
' {:sub.show_date}(date,month,0: current year, 1: birth year)
	print:sys br,"[T]oday's date ("+nl$:gosub {:sub.show_date}(dx,mx,0):print ")"
{:117}
	sys br,"[A]nother date (choose month and day)"+r$+nl$
	print:print "[T/A]: ";
{:119}
	gosub {:sub.cursor_get}:sys is,"ta",chr$(asc(an$) and 127):on i%+1 goto {:119},{:121},{:122}
{:121}
' day, month, year:
	print "Today.":gosub {:sub.set_date}(d,m,0):return
{:122}
	print "Another."
{:123}
	an$=mid$(d1$,2,2):print "Month (1-12) ["k$"="an$"]: ";:sys si,3,4,an$
' calc days in month:
	gosub {:string.normalize}(an$):m=an:if m<1 or m>12 then {:123}
	if m=1 or m=3 or m=5 or m=7 or m=8 or m=10 or m=12 then j%=31
	if m=4 or m=6 or m=9 or m=11 then j%=30
' calc leap year (month=feb & year evenly divisible by 4):
	if m=2 then j%=28:if y/4=int(y/4) then j%=29
	an$=mid$(d1$,4,2)
{:130}
	print "  Day (1-"mid$(str$(j%),2)") ["k$"="an$"]: ";:sys si,3,4,an$
	gosub {:string.normalize}(an$):d=an:if d<1 or d>j% then {:130}
	gosub {:sub.set_date}(d,m,1):return

{:136}

' The reason is 'cause I used to use an array of names. I decided using two
' strings for both would save a little memory. I didn't update the method, and
' the old method started displaying with an array element of 0.
' If the race was 0, it would print starting from (0*8-7) to (0*8) -- -7 to 0.
' Guess what? You can't print a part of a string starting from a position of
' -7.

	x$="M":gosub {:check.gender}:if s=. then x$="Fem"
	print "{off}(1)   Sex: "X$"ale"
	print "(2)  Name: "A$(.)
	print "(3) Class: "mid$(cl$,(peek(v1+68)+1)*8-7,8)
	print "(4)  Race: "mid$(rc$,(peek(v2+185)+1)*8-7,8)
	print "(5)   Age:";:y=peek(v1+144):if y=. then print " Unknown";:goto {:142}
' TODO (if age unknown):
' female: a girl never tells
'   male: ...insert witty comment here
	print y"years"
	print tab(11)"(Born ";:gosub {:sub.show_date}(peek(v1+98),peek(v1+99),1):print ")"
{:142}
	print:print "Enter 1-5 to change, or hit "K$" if correct: {off}";
{:143}
	gosub {:sub.cursor_get}:if an$=r$ then print "Done.":print:goto {:guild_choice}
	gosub {:string.normalize}(an$):if an<1 and an>5 then {:143}
	print an$".":on an gosub {:150},{:32},{:sub.choose_class},{:sub.choose_race},{:86}:print:goto {:136}
{:150}
	gosub {:bit.flip}(v1+64,1)

{:guild_choice}
' guild choice:
	gosub {:sub.block_read}(3)
	an$="":print "Which guild would you like to join?"
'	sys br,r$+"[C]ivilian, [G]uild Member, or [O]utlaw >> "+nl$
' civilian
' guild member ' 12
' outlaw
	print tab(14):sys br,"[C]ivilian"+r$+nl$
	print tab(14):sys br,"[O]utlaw"+r$+nl$
	print tab(14):sys br,"[G]uild member"+r$+nl$
	print tab(5)"Which >> ";
{:185}
	gosub {:sub.cursor_get}:sys is,"cog",chr$(asc(an$) and 127)
	on i%+1 goto {:185},{:civy},{:outlaw},{:guild}

{ifdef:bbs}
	if tr%<1 then {:1811}
{endif}

{:civy}
	print "Civilian.":poke v1+69,.:goto {:attributes}
{:outlaw}
	print "Outlaw.":print:print:poke v1+69,4:goto {:205}
{:guild}
	print "Join Guild.":print
{:205}
	print "{on}"q$"Which guild would you like to join?"q$" asks Verus, waiting expectantly.{off}"
	print
' possible claw symbols: //>
' this is neat: (//////) - scroll header?
	print tab(12):sys br,"[F]ist "+nl$:print " =[]"
	print tab(12):sys br,"[S]word"+nl$:print " -]==="
	print tab(12):sys br,"[C]law "+nl$:print " />>"
	print tab(12):sys br,"[N]one "+nl$:print " (Civilian)"
	print "   Guild >> ";
{:220}
	gosub {:sub.cursor_get}:sys is,"nfsc",chr$(asc(an$) and 127):if i%=. then {:220}
' set guild to i%-1 if not "none"
	if i%>1 then poke v1+69,i%-1:on i% goto {:225},{:230},{:235}
{:240}
	print "None.":print:goto {:attributes}
{:225}
	print "Fist.":goto {:attributes}
{:230}
	print "Sword.":goto {:attributes}
{:235}
	print "Claw."

{:attributes}
	print:print "{on}"q$"You will have 5 chances to roll for "A$(.)"'s attributes."q$:Z=.
{:255}
	Z=Z+1:IF Z=6 THEN print q$"Sorry, you're stuck with these scores,"q$" Verus says.":goto {:400}
	print "{off}":print "["MID$(STR$(Z),2)" of 5] Rolling...";
' class adjustments
' goto now gosub targets, fixed labels. 9/10/2011
{:265}
	on peek(v1+68) gosub {:class.1}, {:class.2}, {:class.3}, {:class.4}, {:class.5}, {:class.6}, {:class.7}, {:class.8}, {:class.9}:goto {:class.calculate}
{:class.1}
	A$=" 0-1 0 0+2 0 0 0":return
{:class.2}
	A$=" 0 0 0 0+2-1+2 0":return
{:class.3}
	A$=" 0+2-1 0-1+2 0+2":return
{:class.4}
	A$=" 0 0+1 0+1+1+1 0":return
{:class.5}
	A$=" 0 0 0 0-1+1-1 0":return
{:class.6}
	A$=" 0 0+1 0 0 0 0+2":return
{:class.7}
	A$=" 0 0+2 0 0 0 0-1":return
{:class.8}
	A$=" 0 0-1 0 0+2 0 0":return
{:class.9}
	A$=" 0+1 0 0+1 0 0-1":return

{:class.calculate} ' 275
	y=v1+86:for x=1 to 8:b=18:if x>3 then b=25
{:276}
	n=fn r(b):if n=1 then {:276}
	n=n+val(mid$(a$,x*2-1,2)):if n<1 then {:276}
	if n>b then n=b
	poke y,n:y=y+1:print ".";
	next:y=v1+86
' race adjustments
' new: changed on/goto to on/gosub
	on peek(v2+185) gosub {:race.1}, {:race.2}, {:race.3}, {:race.4}, {:race.5}, {:race.6}, {:race.7}, {:race.8}, {:race.9}:goto {:race.calculate}
{:race.1}
	A$=" 0 0+1 0+2-1+1-1":return
{:race.2}
	A$=" 0+2-1 0-2+3-1 0":return
{:race.3}
	A$=" 0 0-1 0 0+1+1 0":return
{:race.4}
	A$=" 0-1+2 0+1 0+2 0":return
{:race.5}
	A$=" 0 0+1 0+2-1 0+1":return
{:race.6}
	A$=" 0+1+2 0+2-1 0 0":return
{:race.7}
	A$=" 0+1-1 0 0+2 0 0":return
{:race.8}
	A$=" 0 0+1 0-1+2-1+2":return
{:race.9}
	A$=" 0 0+1 0 0 0+1 0":return
{:race.calculate}
' todo: v1+86 shows up a few times, maybe pick different var for it
' instead of 'y'
	b=18:y=v1+86:for x=1 to 8:n=peek(y):if x=4 then b=25
	n=n+val(mid$(a$,x*2-1,2)):if n<=. then n=3:goto {:299}
	if n>b then n=b
{:299}
	poke y,n:y=y+1:print ".";:next
	y=.:for x=.to 7:y=y+peek(v1+86+x):next
' hp based on adding stats together:
	y=int(y/8)+fn r(10):poke v1+225,y
	print ".":print:print tab(17)"Out":print tab(11)"Score Of:    %":x=peek(v1+225)
' gosub {:sub.percentage}(number,percentage_of,width 1-3,columns 1/2)
	print "  Hit Points:";:gosub {:sub.percentage}(x,x,3,2)
	print "    Charisma:";:gosub {:sub.percentage}(peek(v1+86),18,2,2)
	print "Constitution:";:gosub {:sub.percentage}(peek(v1+87),18,2,2)
	print "   Dexterity:";:gosub {:sub.percentage}(peek(v1+88),18,2,2)
	print tab(9)"Ego:";:gosub {:sub.percentage}(peek(v1+89),18,2,2)
	print "Intelligence:";:gosub {:sub.percentage}(peek(V1+90),25,2,2)
	print "    Strength:";:gosub {:sub.percentage}(peek(V1+91),25,2,2)
	print tab(6)"Wisdom:";:gosub {:sub.percentage}(peek(V1+92),25,2,2):print
	print "Energy Level:";:gosub {:sub.percentage}(peek(V1+93),25,2,2)
' fixme: char might not start w/ shield
	print tab(6)"Shield:";:if x then:gosub {:sub.percentage}(peek(v1+71),100,3,2):goto {:358}
	print " None"
{:358}
' fixme: char might not start w/ armor
	print tab(7)"Armor:";:if x then:gosub {:sub.percentage}(peek(v1+71),100,3,2):goto {:365}
	print " None"
{:365}
	print:print "Is this okay";
{:370}
	gosub {:sub.yes_no}(1):if a=. then {:255}
'	gosub {:sub.cursor_get}:sys is,"yn",an$:if i%=. then {:370}
'	if i%=1 then print "Yes.":goto {:400}
'	print "No.":goto {:255}

{:400}
	print:print "Verus croaks, "q$"Hold while you are entered into the log..."q$:print
' todo: log - date,"new player", name, civy/guild/outlaw

' current alignment un-needed because of honor: POKE V1+67,X
' set natural alignment (0=good, 1=neutral, 2=evil) based on race:
	poke v1+70,val(mid$("120011121",peek(v2+185),1))

' player quote:
	gosub {:sub.block_read}(4)
{:quote}
	print:an$="Hi, $!":print "Quote: ";:sys si,254,32,an$
{ifdef:debug}
	print "Quote: "an$
{endif}
	z=len(an$):if z=. then print:print q$"Okay, fine."q$:goto {:535}
' todo: write flag (silent= "-"?) in e.t.playerquotes
' todo: optimize this routine using instring:
	sys is,an$,"$":if i%=. then {:display_quote}

'for y=z to 1 step-1
'	for x=1 to y
'		if mid$(an$,y,1)="$" then an$=left$(an$,y-1)+a$(0)+mid$(an$,y+1):z=z+1
'	next
'next

' found $, print name, skip over $, compare to length of string:
'	y=i%+1:if y=>z then

' start at L ($ position):
'{:loop}
'	sys is,mid$(an$,L),"$":if i%=0 then print mid$(an$,L):goto {:loop.end}
' 	L=L+i%+1:goto {:loop}
'{:loop.end}

{:display_quote}
	print "You say:":print q$an$q$

	print:print "Is this okay";
	gosub {:sub.yes_no}(1):if a=. then {:quote}
' todo: write an$ to e.t.playerquotes
{:535}
' 6 - new player post-creation info
	gosub {:sub.block_read}(6):gosub {:sub.pause}

{ifdef:bbs}
	print "Note that inactive players are removed after two weeks."
	print R$"See the TADA Annex in the PF section for help files."
	print R$"Stand by. Creating account...";
{endif}

' todo: assign random combination (3 digits, 0-99), random room on level 1
' make sure it's not a room containing water

' fixme: currently there is an overflow in record error that kills this whole deal...
	print "Adding you to the world..."
	gosub {:record_pointer}(pn):gosub {:check.io_status}:if e then {:error}
	print# 2,d$:print ".";:gosub {:check.io_status}:if e then {:error}
	gosub {:record_pointer}(pn+1):gosub {:check.io_status}:if e then {:error}
	print# 2,d2$:print ".";:gosub {:check.io_status}:if e=. then {:finish}

{:error}
	print "(:error) "a$:goto {:1811}
' todo: log error to disk

{:finish}
' 7 - new player challenge
	gosub {:sub.block_read}(7):gosub {:sub.pause}

' farewell, starting the adventure:
	gosub {:link.module}("startup","")

{remremoval:off}

{ifdef:include_filler}
' this links to t.main
	{number:899}
{else}
' this is last line in standalone module:
	{number: 999}
{endif}

	rem "t.np"
